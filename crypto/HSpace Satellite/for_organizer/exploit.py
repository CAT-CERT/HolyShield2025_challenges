from sage.all import *
from Crypto.Util.number import long_to_bytes, bytes_to_long, inverse
from hashlib import sha512, sha256

# =============================================================================
# 1. SETUP & DATA
# =============================================================================

n = 0xaadd9db8dbe9c48b3fd4e6ae33c9fc07cb308db3b3c9d20ed6639cca70330870553e5c414ca92619418661197fac10471db1d381085ddaddb58796829ca90069
Mersenne61 = 2**61 - 1
leaked_hash = 2162479443294769559

# (msg_int, r, s)
sigs = [
    (0x1337, 
     8147508699761285994978610589515560085938228069874267601813630112326703300118886420766049974019325779453617325010637104077814810343524288894933433019443757, 
     2233260891482144354659438825461103155329678129873793459397359325916878155408376021458302639076096525117447380333890248141138621804376530867025040540418411),
    (0x13371337, 
     5777720515030952206459393086149624455207109910779230988774521914735330369864739872570733005585673264621727574921665435480542072431286685403226535219889144, 
     3752510594064690170257955630592880111200269469204274424630875385088631768028448046163121387484733019068751197216466163550156947641552955547766861912423576),
    (0x133713371337, 
     343729789356173334660983161153915296826269631358108159173092254221915369811683225440337789134968499802427001788784359605688620482459809128631232997098873, 
     8728067307130619986664517738909551768261644935806063927332256533437812966024421230551931577647544051649982299601172264537861686588483470513971826181295013)
]

# =============================================================================
# 2. LATTICE CONSTRUCTION
# =============================================================================
print("[*] Constructing Balanced HNP Lattice...")

# Constants
num_sigs = len(sigs)
bits_leak = 256
bits_mod = 521 # The size of n

# --- SCALING STRATEGY ---
# Unknowns: k_high (~2^256), d (~2^512)
# We must scale the equations so k_high * SCALE approx d.
# SCALE = 2^(512 - 256) = 2^256.
SCALE = 2**256 
K_BOUND = 2**256 # The max size of the constant column (for CVP embedding)

# Matrix dimensions: (num_sigs + 2) x (num_sigs + 2)
# Columns 0..2: The equations (Scaled by SCALE)
# Column 3:     The variable d
# Column 4:     The constant K (Embedding CVP into SVP)

M = Matrix(ZZ, num_sigs + 2, num_sigs + 2)

for i in range(num_sigs):
    msg_int, r, s = sigs[i]
    
    # Calculate derived values
    msg_bytes = long_to_bytes(msg_int)
    z = bytes_to_long(sha512(msg_bytes).digest())
    k_low = bytes_to_long(sha256(msg_bytes).digest())
    
    # HNP Coefficients
    # k_high - d*t - u = 0 (mod n)
    # where t = r * s^-1 * 2^-256
    # where u = (z * s^-1 - k_low) * 2^-256
    
    s_inv = inverse_mod(s, n)
    pow_inv = inverse_mod(2**bits_leak, n)
    
    t = (r * s_inv * pow_inv) % n
    u = ((z * s_inv - k_low) * pow_inv) % n
    
    # Fill Matrix
    # Row i corresponds to modulus n (to handle the modulo reduction)
    M[i, i] = n * SCALE
    
    # Row 'd' (index num_sigs)
    # Contribution to eq i is: -t * SCALE
    M[num_sigs, i] = -t * SCALE
    
    # Row 'const' (index num_sigs + 1)
    # Contribution to eq i is: -u * SCALE
    M[num_sigs+1, i] = -u * SCALE

# Set up the 'd' column
M[num_sigs, num_sigs] = 1  # This will hold the value 'd'

# Set up the 'K' column (Target embedding)
M[num_sigs+1, num_sigs+1] = K_BOUND

# =============================================================================
# 3. LATTICE REDUCTION
# =============================================================================
print("[*] Running LLL...")
L = M.LLL()

recovered_d = None

print("[*] Searching for d...")
for row in L:
    # Our target vector 'd' is located in the second-to-last column.
    # The last column should be close to +/- K_BOUND
    
    candidate_d = row[num_sigs]
    if candidate_d < 0: candidate_d = -candidate_d
    
    # Filter junk results
    if candidate_d > n or candidate_d < 2**500:
        continue
        
    # VERIFY CANDIDATE
    # Check if this d satisfies the first signature equation
    msg0, r0, s0 = sigs[0]
    z0 = bytes_to_long(sha512(long_to_bytes(msg0)).digest())
    
    # Calculate k
    k_check = (inverse_mod(s0, n) * (z0 + r0 * candidate_d)) % n
    
    # Check if LSBs match
    k_low_expected = bytes_to_long(sha256(long_to_bytes(msg0)).digest())
    if (k_check % 2**256) == k_low_expected:
        print(f"[+] LLL Success! Recovered d: {candidate_d}")
        recovered_d = candidate_d
        break

if not recovered_d:
    print("[-] Failed to find d. The lattice might still be unbalanced.")
    exit()

# =============================================================================
# 4. CRT & BRUTE FORCE
# =============================================================================
print("[*] Applying CRT...")

# Setup moduli
m_n = n
m_hash = Mersenne61

# Handle hash
h_val = leaked_hash
if h_val < 0: h_val += m_hash

# Combine
crt_val = crt([Integer(recovered_d), Integer(h_val)], [m_n, m_hash])
combined_mod = m_n * m_hash

print(f"[+] CRT Result: {crt_val}")
print("[*] Brute-forcing final overflow...")

# The flag is only slightly larger than n (512 vs ~600 bits)
# k will be very small (0 to 1000)
for k in range(10000):
    flag_int = k * combined_mod + crt_val
    try:
        flag_bytes = long_to_bytes(flag_int)
        if b'HolyShield{' in flag_bytes:
            print(f"\n[SUCCESS] Flag Found:\n{flag_bytes.decode()}")
            print(k)
            break
    except:
        pass