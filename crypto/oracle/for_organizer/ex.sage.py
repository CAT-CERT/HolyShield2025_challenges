

# This file was *autogenerated* from the file ex.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0xFFFFFFFFFFFFFFFF = Integer(0xFFFFFFFFFFFFFFFF); _sage_const_64 = Integer(64); _sage_const_0x1234567890abcdef = Integer(0x1234567890abcdef); _sage_const_0x1122334455667788 = Integer(0x1122334455667788); _sage_const_0x9988776655443322 = Integer(0x9988776655443322); _sage_const_0xaabbccddeeff0011 = Integer(0xaabbccddeeff0011); _sage_const_0x0000000000000001 = Integer(0x0000000000000001); _sage_const_0xcafebabecafebabe = Integer(0xcafebabecafebabe); _sage_const_0xfeedfacefeedface = Integer(0xfeedfacefeedface); _sage_const_0xdeadbeefdeadbeef = Integer(0xdeadbeefdeadbeef); _sage_const_0x0102030405060708 = Integer(0x0102030405060708); _sage_const_0x090a0b0c0d0e0f10 = Integer(0x090a0b0c0d0e0f10); _sage_const_0x1011121314151617 = Integer(0x1011121314151617); _sage_const_0x18191a1b1c1d1e1f = Integer(0x18191a1b1c1d1e1f); _sage_const_0x2021222324252627 = Integer(0x2021222324252627); _sage_const_0x28292a2b2c2d2e2f = Integer(0x28292a2b2c2d2e2f); _sage_const_0x3031323334353637 = Integer(0x3031323334353637); _sage_const_0x38393a3b3c3d3e3f = Integer(0x38393a3b3c3d3e3f); _sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_0x5555555555555555 = Integer(0x5555555555555555); _sage_const_0xffffffff = Integer(0xffffffff); _sage_const_4 = Integer(4); _sage_const_1 = Integer(1); _sage_const_0x1337_BEEF = Integer(0x1337_BEEF); _sage_const_88 = Integer(88); _sage_const_0xFFFFFFFF = Integer(0xFFFFFFFF); _sage_const_0xFF = Integer(0xFF); _sage_const_24 = Integer(24); _sage_const_16 = Integer(16); _sage_const_3 = Integer(3); _sage_const_50 = Integer(50); _sage_const_10 = Integer(10); _sage_const_45 = Integer(45); _sage_const_8 = Integer(8); _sage_const_1p0 = RealNumber('1.0'); _sage_const_0p03 = RealNumber('0.03')# solve.sage
import hashlib
import binascii

# ----------------------------------------------------------------
# 1. Rust 로직 재구현 (파라미터 복구)
# ----------------------------------------------------------------

def rotate_right_u64(n, shift):
    # 64비트 정수 회전 연산
    n = int(n) & _sage_const_0xFFFFFFFFFFFFFFFF 
    return ((n >> shift) | (n << (_sage_const_64  - shift))) & _sage_const_0xFFFFFFFFFFFFFFFF 

def get_modulus_n():
    print("[*] Reconstructing Modulus N...")
    raw_parts = [
        _sage_const_0x1234567890abcdef , _sage_const_0x1122334455667788 , _sage_const_0x9988776655443322 , _sage_const_0xaabbccddeeff0011 ,
        _sage_const_0x0000000000000001 , _sage_const_0xcafebabecafebabe , _sage_const_0xfeedfacefeedface , _sage_const_0xdeadbeefdeadbeef ,
        _sage_const_0x0102030405060708 , _sage_const_0x090a0b0c0d0e0f10 , _sage_const_0x1011121314151617 , _sage_const_0x18191a1b1c1d1e1f ,
        _sage_const_0x2021222324252627 , _sage_const_0x28292a2b2c2d2e2f , _sage_const_0x3031323334353637 , _sage_const_0x38393a3b3c3d3e3f 
    ]
    
    pressure = _sage_const_0 
    for i, part in enumerate(raw_parts):
        # SageMath에서 XOR 연산자는 '^^'
        twist = rotate_right_u64(i, _sage_const_2 ) ^ _sage_const_0x5555555555555555 
        val = part ^ twist
        pressure = pressure + (val << (i * _sage_const_64 ))
    return pressure

def find_seed():
    print("[*] Finding Seed (Brute-force)...")
    salt = b"OrAcLe"
    # Rust 코드와 동일한 조건: SHA256의 상위 3바이트가 000000
    # 보통 CTF 문제는 앞쪽 범위에서 나오도록 설계됨
    for i in range(_sage_const_0xffffffff ): 
        b_seed = int(i).to_bytes(_sage_const_4 , 'big')
        h = hashlib.sha256(b_seed + salt).digest()
        if h[_sage_const_0 ] == _sage_const_0  and h[_sage_const_1 ] == _sage_const_0  and h[_sage_const_2 ] == _sage_const_0 :
            print(f"[+] Found Seed: {i}")
            return i
    return None

def generate_prefix(seed):
    print("[*] Generating Prefix...")
    chronicle = []
    magic_constant = _sage_const_0x1337_BEEF 
    for i in range(_sage_const_88 ):
        # 32비트 오버플로우 처리
        val_add = (seed + i) & _sage_const_0xFFFFFFFF 
        val_mul = (val_add * magic_constant) & _sage_const_0xFFFFFFFF 
        val = val_mul ^ _sage_const_0xFF   # XOR
        chronicle.append((val >> _sage_const_24 ) & _sage_const_0xFF )
    return bytes(chronicle)

# ----------------------------------------------------------------
# 2. Coppersmith Attack (복호화 수행)
# ----------------------------------------------------------------

def solve():
    # 1. 파라미터 준비 (N, Seed, Prefix)
    N = get_modulus_n()
    seed = find_seed()
    
    if seed is None:
        print("[-] Seed not found. Check the range or implementation.")
        return

    prefix_bytes = generate_prefix(seed)
    prefix_int = Integer(int(binascii.hexlify(prefix_bytes), _sage_const_16 ))
    e = _sage_const_3 

    # 2. 암호문 입력 받기
    print("\n" + "="*_sage_const_50 )
    print("Paste the HEX Output from the Rust program:")
    try:
        c_hex = input("Ciphertext > ").strip()
        C = Integer(int(c_hex, _sage_const_16 ))
    except:
        print("[-] Invalid Hex String")
        return

    print("\n[*] Starting Coppersmith's Stereotyped Message Attack...")
    
    # 다항식 링(Polynomial Ring) 설정
    P = PolynomialRing(Zmod(N), implementation='NTL', names='x')
    (x,) = P._first_ngens(_sage_const_1 )

    # Flag의 길이를 정확히 모르므로, 가능한 길이(20~42 바이트)를 순회하며 시도
    # N이 1024비트이고 e=3이므로, 복구 가능한 미지수(Flag)의 최대 크기는
    # 약 1024 / 3 = 341비트 (약 42바이트)입니다.
    found_flag = False
    
    for flag_len in range(_sage_const_10 , _sage_const_45 ):
        shift_bits = flag_len * _sage_const_8 
        
        # 방정식 구성: (Prefix * 2^shift + x)^3 - C ≡ 0 (mod N)
        # 여기서 ^는 SageMath의 거듭제곱 연산
        f = (prefix_int * (_sage_const_2 **shift_bits) + x)**e - C
        
        # 해의 상한선 설정 (Flag는 flag_len 바이트 크기이므로)
        upper_bound = _sage_const_2 **(shift_bits)
        
        try:
            # small_roots를 사용하여 작은 해(Flag) 탐색
            # epsilon: 탐색 정밀도 (작을수록 느리지만 성공 확률 높음)
            roots = f.small_roots(X=upper_bound, beta=_sage_const_1p0 , epsilon=_sage_const_0p03 )
            
            if roots:
                # 해를 찾음
                root = Integer(roots[_sage_const_0 ])
                flag_hex = hex(root)[_sage_const_2 :]
                
                # 짝수 길이 보정
                if len(flag_hex) % _sage_const_2  != _sage_const_0 :
                    flag_hex = '0' + flag_hex
                    
                try:
                    flag_str = binascii.unhexlify(flag_hex).decode()
                    print(f"\n[SUCCESS] Flag found (len={flag_len}): {flag_str}")
                    found_flag = True
                    break
                except:
                    # 디코딩 실패 시 (쓰레기 값일 경우 무시)
                    continue
        except:
            continue
            
    if not found_flag:
        print("\n[-] Failed to recover the flag.")
        print("    Possible reasons:")
        print("    1. The flag is too long (> 42 bytes).")
        print("    2. The input ciphertext is incorrect.")

# 실행
if __name__ == "__main__":
    solve()

